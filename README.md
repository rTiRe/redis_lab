# Практическая работа №4 (Redis) - Тюрин Артём К0709-22

Docker Compose присутствует, **но** для запуска лучше воспользоваться тем, что лежит в папке scripts, потому что `.env` файлы лежат не в той же директории, что и `docker-compose.yml`, а он из-за этого будет выделываться. Запускать скрипты из основной папки, не из `scripts/`!

#### Запустить в detached режиме
```
scripts/remote.sh start
```

#### Посмотреть логи
```
scripts/remote.sh logs
```

#### Перезапустить
```
scripts/remote.sh restart
```

#### Остановить
```
scripts/remote.sh stop
```

#### Запустить в attchaed режиме
```
scripts/remote.sh start_attached
```

#### Собрать/пересобрать
```
scripts/remote.sh rebuild
```

После каждой из команд можно указывать название контейнера, к котрому ее применить, из доступных: `consumer` и `publisher`.

Перед запуском настроить `.env` внутри `consumer/config` и `publisher/config`. Будет достаточно просто переименовать `.env.example` в `.env`.

## • Как используется Redis (что хранится, каков формат ключей и тд)
В редис хранится ключ в виде сгенерированного uuid v5 на основе сообщения и значение в виде идентификатора таблицы, в которой это сообщение точно находится
## • Как Вы решаете проблему с повторной обработкой сообщений в Redis
Я добавиляю ключи с временем жизни 30 секунд, наличие которого определяет то, что с этим полем уже работает какой-то сервис. Каждый сервис смотрит наличие этого ключа.
## • Какая Eviction policy выбрана или как реализован TTL и почему
#### Выбранная стратегия: Volatile LRU (Least Recently Used)
Redis автоматически удаляет ключи с истекшим TTL, если память заполнена.

#### Настройки TTL:
Ключ | TTL | Причина
-----|-----|--------
`lock:{message_id}` | 30 сек | Кратковременная блокировка
`processed:{message_id}` | 24 часа | Достаточно для дедупликации

• Блокировки не должны висеть долго (если консьюмер упал, они автоматически снимаются через 30 сек).

• Обработанные сообщения хранятся 24 часа, чтобы избежать повторной обработки после перезапуска.
## • Сценарии сбоя: что происходит, если Redis перезапущен или очищен (можно продумать синхронизацию с базой)
#### Если Redis перезапущен/очищен:
Консьюмеры начнут обрабатывать сообщения заново и заполнять redis
#### Решение:
Если нужного ключа нет в redis, смотрим его в базе данных. Если он есть в базе данных - добавляем в редис. Нет даже в базе данных - считаем.
## • Как вы решили проблему гонки
Добавил ключи, говорящие о том, что поле заблокировано для обновления `lock:{message_id}` и ключи, говорящие о том, что такое сообщение уже было обработано `processed:{message_id}`
#### Почему это работает?
**SETNX атомарный** → только один консьюмер получает блокировку.

**TTL на блокировке** → если консьюмер упал, блокировка снимется через 30 сек.

**Двойная проверка ключи (`processed` + `lock`)** → гарантирует, что сообщение не обработано дважды.